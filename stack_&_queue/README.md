// 🧱 C++ Stack Operations (STL <stack>)

// Stack Operations
// 1️⃣ push(x) → Add x to top → O(1)
// 2️⃣ pop() → Remove top element → O(1)
// 3️⃣ top() → Access top element → O(1)
// 4️⃣ empty() → Check if stack is empty → O(1)
// 5️⃣ size() → Get current size → O(1)
// 6️⃣ swap(s2) → Swap with another stack → O(1)
// 7️⃣ emplace(x) → Efficient push → O(1)

// 🚀 C++ Queue Operations (STL <queue>)

// 1️⃣ push(x) → Add x to back
// 2️⃣ pop() → Remove front element
// 3️⃣ front() → Access front element
// 4️⃣ back() → Access back element
// 5️⃣ empty() → Check if queue is empty
// 6️⃣ size() → Get current size
// 7️⃣ swap(q2) → Swap with another queue
// 8️⃣ emplace(x) → Efficient push for complex objects // all O(1)

🔄 Common Tips

1. Stack: Best for reversal problems or nested structures.
2. Queue: Best for level-order traversal or sequential task processing.
3. Use deque for sliding window max/min in O(n).
4. Master Queue using 2 Stacks & Stack using 2 Queues (frequent interview pattern).
